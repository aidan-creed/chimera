// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO "user_roles" (user_id, role_id) VALUES ($1, $2)
ON CONFLICT (user_id, role_id) DO NOTHING
`

type AssignRoleToUserParams struct {
	UserID int64 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

// Assign a specific role to a user
func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const assignScopeToUser = `-- name: AssignScopeToUser :exec
INSERT INTO "user_scope_access" (user_id, scope) VALUES ($1, $2)
ON CONFLICT (user_id, scope) DO NOTHING
`

type AssignScopeToUserParams struct {
	UserID int64  `json:"user_id"`
	Scope  string `json:"scope"`
}

// Grants a user access to a specific scope
func (q *Queries) AssignScopeToUser(ctx context.Context, arg AssignScopeToUserParams) error {
	_, err := q.db.Exec(ctx, assignScopeToUser, arg.UserID, arg.Scope)
	return err
}

const createUserFromAuthProvider = `-- name: CreateUserFromAuthProvider :one
INSERT INTO "users" (
	auth_provider_subject,
	email,
	display_name,
	is_active,
	is_admin
) VALUES (
	$1, $2, $3, TRUE, FALSE
)
RETURNING id, auth_provider_subject, email, display_name, is_active, is_admin, updated_at, created_at
`

type CreateUserFromAuthProviderParams struct {
	AuthProviderSubject string      `json:"auth_provider_subject"`
	Email               string      `json:"email"`
	DisplayName         pgtype.Text `json:"display_name"`
}

// Creates a new user record from the authentication provider's details
func (q *Queries) CreateUserFromAuthProvider(ctx context.Context, arg CreateUserFromAuthProviderParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserFromAuthProvider, arg.AuthProviderSubject, arg.Email, arg.DisplayName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.DisplayName,
		&i.IsActive,
		&i.IsAdmin,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByAuthProviderSubject = `-- name: GetUserByAuthProviderSubject :one
SELECT id, auth_provider_subject, email, display_name, is_active, is_admin, updated_at, created_at FROM "users" WHERE auth_provider_subject = $1
`

// Fetch a single user by their external auth provider ID
func (q *Queries) GetUserByAuthProviderSubject(ctx context.Context, authProviderSubject string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByAuthProviderSubject, authProviderSubject)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.DisplayName,
		&i.IsActive,
		&i.IsAdmin,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description FROM "roles" ORDER BY id
`

// Fetch all available roles in system
func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllRolesFromUser = `-- name: RemoveAllRolesFromUser :exec
DELETE FROM "user_roles" WHERE user_id = $1
`

// Removes all roles from a user. Useful when completely re-assigning roles
func (q *Queries) RemoveAllRolesFromUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, removeAllRolesFromUser, userID)
	return err
}

const removeAllScopesFromUser = `-- name: RemoveAllScopesFromUser :exec
DELETE FROM "user_scope_access" WHERE user_id = $1
`

// Removes all scope access from a user
func (q *Queries) RemoveAllScopesFromUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, removeAllScopesFromUser, userID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM "user_roles" WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleFromUserParams struct {
	UserID int64 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

// Removes a specific role from a user
func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, removeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const removeScopeFromUser = `-- name: RemoveScopeFromUser :exec
DELETE FROM "user_scope_access" WHERE user_id = $1 AND scope = $2
`

type RemoveScopeFromUserParams struct {
	UserID int64  `json:"user_id"`
	Scope  string `json:"scope"`
}

// Revokes a user's access from a specific scope.
func (q *Queries) RemoveScopeFromUser(ctx context.Context, arg RemoveScopeFromUserParams) error {
	_, err := q.db.Exec(ctx, removeScopeFromUser, arg.UserID, arg.Scope)
	return err
}

const setUserAdminStatus = `-- name: SetUserAdminStatus :one
UPDATE "users"
SET
	is_admin = $2
WHERE
	id = $1
RETURNING id, auth_provider_subject, email, display_name, is_active, is_admin, updated_at, created_at
`

type SetUserAdminStatusParams struct {
	ID      int64 `json:"id"`
	IsAdmin bool  `json:"is_admin"`
}

// Updates only the is_admin status of a specific user
// This is a priviliged action and should be protected at API layer
func (q *Queries) SetUserAdminStatus(ctx context.Context, arg SetUserAdminStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, setUserAdminStatus, arg.ID, arg.IsAdmin)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.DisplayName,
		&i.IsActive,
		&i.IsAdmin,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "users"
SET
	display_name = $2,
	is_active = $3
WHERE
	id = $1
RETURNING id, auth_provider_subject, email, display_name, is_active, is_admin, updated_at, created_at
`

type UpdateUserParams struct {
	ID          int64       `json:"id"`
	DisplayName pgtype.Text `json:"display_name"`
	IsActive    bool        `json:"is_active"`
}

// Updates a user's mutable details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.DisplayName, arg.IsActive)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.DisplayName,
		&i.IsActive,
		&i.IsAdmin,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
