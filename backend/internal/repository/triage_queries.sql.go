// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: triage_queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIngestionError = `-- name: CreateIngestionError :one
INSERT INTO ingestion_errors (
    id,
    job_id,
    original_row_data,
    reason_for_failure
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, job_id, timestamp, original_row_data, reason_for_failure, status, corrected_data, resolved_at, resolved_by
`

type CreateIngestionErrorParams struct {
	ID               pgtype.UUID `json:"id"`
	JobID            pgtype.UUID `json:"job_id"`
	OriginalRowData  []byte      `json:"original_row_data"`
	ReasonForFailure string      `json:"reason_for_failure"`
}

// Inserts a new ingestion error record for a row that failed processing.
func (q *Queries) CreateIngestionError(ctx context.Context, arg CreateIngestionErrorParams) (IngestionError, error) {
	row := q.db.QueryRow(ctx, createIngestionError,
		arg.ID,
		arg.JobID,
		arg.OriginalRowData,
		arg.ReasonForFailure,
	)
	var i IngestionError
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Timestamp,
		&i.OriginalRowData,
		&i.ReasonForFailure,
		&i.Status,
		&i.CorrectedData,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const createIngestionJob = `-- name: CreateIngestionJob :one
INSERT INTO ingestion_jobs (
	id, 
	source_type,
	source_details,
	item_type,
	status, 
	user_id,
	source_uri
) VALUES (
	$1, $2, $3, $4, $5, $6, $7
)
RETURNING id, source_type, source_details, item_type, status, started_at, completed_at, error_details, user_id, source_uri, total_rows, processed_rows, initial_error_count, resolved_rows_count
`

type CreateIngestionJobParams struct {
	ID            pgtype.UUID `json:"id"`
	SourceType    string      `json:"source_type"`
	SourceDetails []byte      `json:"source_details"`
	ItemType      string      `json:"item_type"`
	Status        string      `json:"status"`
	UserID        pgtype.Int8 `json:"user_id"`
	SourceUri     pgtype.Text `json:"source_uri"`
}

// Inserts a new file ingestion job record.
func (q *Queries) CreateIngestionJob(ctx context.Context, arg CreateIngestionJobParams) (IngestionJob, error) {
	row := q.db.QueryRow(ctx, createIngestionJob,
		arg.ID,
		arg.SourceType,
		arg.SourceDetails,
		arg.ItemType,
		arg.Status,
		arg.UserID,
		arg.SourceUri,
	)
	var i IngestionJob
	err := row.Scan(
		&i.ID,
		&i.SourceType,
		&i.SourceDetails,
		&i.ItemType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorDetails,
		&i.UserID,
		&i.SourceUri,
		&i.TotalRows,
		&i.ProcessedRows,
		&i.InitialErrorCount,
		&i.ResolvedRowsCount,
	)
	return i, err
}

const createTempItemsStagingTable = `-- name: CreateTempItemsStagingTable :exec
CREATE TEMP TABLE temp_items_staging (LIKE items INCLUDING DEFAULTS) ON COMMIT DROP
`

// Creates a temporary table for staging items during ingest
// This table is dropped on commit
func (q *Queries) CreateTempItemsStagingTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempItemsStagingTable)
	return err
}

const getIngestionErrorsByJobID = `-- name: GetIngestionErrorsByJobID :many
SELECT
	id,
	job_id,
	"timestamp",
	original_row_data,
	reason_for_failure,
	status,
	corrected_data,
	resolved_at,
	resolved_by
FROM
	ingestion_errors
WHERE
	job_id = $1 AND status IN ('new', 'pending_revalidation')
ORDER BY
	"timestamp" ASC
`

// Retrieves ingestion errors associated with a specific job ID, with pagination support
func (q *Queries) GetIngestionErrorsByJobID(ctx context.Context, jobID pgtype.UUID) ([]IngestionError, error) {
	rows, err := q.db.Query(ctx, getIngestionErrorsByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IngestionError
	for rows.Next() {
		var i IngestionError
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Timestamp,
			&i.OriginalRowData,
			&i.ReasonForFailure,
			&i.Status,
			&i.CorrectedData,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementIngestionJobResolvedRows = `-- name: IncrementIngestionJobResolvedRows :exec
UPDATE ingestion_jobs
SET
	resolved_rows_count = resolved_rows_count + 1
WHERE
	id = (SELECT job_id FROM ingestion_errors WHERE ingestion_errors.id = $1)
`

func (q *Queries) IncrementIngestionJobResolvedRows(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementIngestionJobResolvedRows, id)
	return err
}

const itemExistsByBusinessKey = `-- name: ItemExistsByBusinessKey :one
SELECT EXISTS(SELECT 1 FROM items WHERE item_type = $1 AND business_key = $2)::int
`

type ItemExistsByBusinessKeyParams struct {
	ItemType    ItemType    `json:"item_type"`
	BusinessKey pgtype.Text `json:"business_key"`
}

// Checks for the existence of an item by its type and business key. Returns 1 if it exists, 0 otherwise.
func (q *Queries) ItemExistsByBusinessKey(ctx context.Context, arg ItemExistsByBusinessKeyParams) (int32, error) {
	row := q.db.QueryRow(ctx, itemExistsByBusinessKey, arg.ItemType, arg.BusinessKey)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listIngestionJobs = `-- name: ListIngestionJobs :many
SELECT 
	id,
	source_type,
	source_details,
	item_type,
	status,
	user_id,
	source_uri,
	started_at,
	completed_at,
	error_details,
	processed_rows,
	initial_error_count,
	resolved_rows_count,
	total_rows
FROM 
	ingestion_jobs
ORDER BY 
	started_at DESC
LIMIT $1 OFFSET $2
`

type ListIngestionJobsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListIngestionJobsRow struct {
	ID                pgtype.UUID        `json:"id"`
	SourceType        string             `json:"source_type"`
	SourceDetails     []byte             `json:"source_details"`
	ItemType          string             `json:"item_type"`
	Status            string             `json:"status"`
	UserID            pgtype.Int8        `json:"user_id"`
	SourceUri         pgtype.Text        `json:"source_uri"`
	StartedAt         pgtype.Timestamptz `json:"started_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	ErrorDetails      pgtype.Text        `json:"error_details"`
	ProcessedRows     pgtype.Int4        `json:"processed_rows"`
	InitialErrorCount pgtype.Int4        `json:"initial_error_count"`
	ResolvedRowsCount pgtype.Int4        `json:"resolved_rows_count"`
	TotalRows         pgtype.Int4        `json:"total_rows"`
}

// Lists ingestion jobs with pagination support
func (q *Queries) ListIngestionJobs(ctx context.Context, arg ListIngestionJobsParams) ([]ListIngestionJobsRow, error) {
	rows, err := q.db.Query(ctx, listIngestionJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIngestionJobsRow
	for rows.Next() {
		var i ListIngestionJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceDetails,
			&i.ItemType,
			&i.Status,
			&i.UserID,
			&i.SourceUri,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorDetails,
			&i.ProcessedRows,
			&i.InitialErrorCount,
			&i.ResolvedRowsCount,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIngestionErrorWithCorrection = `-- name: UpdateIngestionErrorWithCorrection :one
UPDATE ingestion_errors
SET
    corrected_data = $2,
    status = 'pending_revalidation',
    resolved_by = $3,
    resolved_at = NOW()
WHERE
    id = $1
RETURNING id, job_id, timestamp, original_row_data, reason_for_failure, status, corrected_data, resolved_at, resolved_by
`

type UpdateIngestionErrorWithCorrectionParams struct {
	ID            pgtype.UUID `json:"id"`
	CorrectedData []byte      `json:"corrected_data"`
	ResolvedBy    pgtype.Int8 `json:"resolved_by"`
}

func (q *Queries) UpdateIngestionErrorWithCorrection(ctx context.Context, arg UpdateIngestionErrorWithCorrectionParams) (IngestionError, error) {
	row := q.db.QueryRow(ctx, updateIngestionErrorWithCorrection, arg.ID, arg.CorrectedData, arg.ResolvedBy)
	var i IngestionError
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Timestamp,
		&i.OriginalRowData,
		&i.ReasonForFailure,
		&i.Status,
		&i.CorrectedData,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const updateIngestionJobStatus = `-- name: UpdateIngestionJobStatus :exec
UPDATE ingestion_jobs
SET
	status = $2,
	completed_at = NOW(),
	error_details = $3,
	processed_rows = $4,
	initial_error_count = $5
WHERE
	id = $1
`

type UpdateIngestionJobStatusParams struct {
	ID                pgtype.UUID `json:"id"`
	Status            string      `json:"status"`
	ErrorDetails      pgtype.Text `json:"error_details"`
	ProcessedRows     pgtype.Int4 `json:"processed_rows"`
	InitialErrorCount pgtype.Int4 `json:"initial_error_count"`
}

// Updates the status and details of an ingestion job
func (q *Queries) UpdateIngestionJobStatus(ctx context.Context, arg UpdateIngestionJobStatusParams) error {
	_, err := q.db.Exec(ctx, updateIngestionJobStatus,
		arg.ID,
		arg.Status,
		arg.ErrorDetails,
		arg.ProcessedRows,
		arg.InitialErrorCount,
	)
	return err
}
