// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: insurance_queries.sql

package insurance

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const getClaimDetails = `-- name: GetClaimDetails :one
SELECT
    c.id, c.item_type, c.claim_id, c.policy_number, c.system_status, c.created_at, c.updated_at,
    c.policyholder_id, c.claim_type, c.date_of_loss, c.description_of_loss, c.claim_amount,
    c.business_status, c.adjuster_assigned, p.policyholder_name, p.city, p.state,
    p.customer_since_date, p.customer_level
FROM vw_insurance_claims c
JOIN vw_policyholders p ON c.policyholder_id = p.policyholder_id
WHERE c.id = $1
`

type GetClaimDetailsRow struct {
	ID                int64              `json:"id"`
	ItemType          ItemType           `json:"item_type"`
	ClaimID           pgtype.Text        `json:"claim_id"`
	PolicyNumber      pgtype.Text        `json:"policy_number"`
	SystemStatus      ItemStatus         `json:"system_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PolicyholderID    string             `json:"policyholder_id"`
	ClaimType         string             `json:"claim_type"`
	DateOfLoss        pgtype.Date        `json:"date_of_loss"`
	DescriptionOfLoss string             `json:"description_of_loss"`
	ClaimAmount       pgtype.Numeric     `json:"claim_amount"`
	BusinessStatus    string             `json:"business_status"`
	AdjusterAssigned  string             `json:"adjuster_assigned"`
	PolicyholderName  string             `json:"policyholder_name"`
	City              string             `json:"city"`
	State             pgtype.Text        `json:"state"`
	CustomerSinceDate pgtype.Date        `json:"customer_since_date"`
	CustomerLevel     string             `json:"customer_level"`
}

// Fetches a single claim joined with its correspondng policyholder data
func (q *Queries) GetClaimDetails(ctx context.Context, id int64) (GetClaimDetailsRow, error) {
	row := q.db.QueryRow(ctx, getClaimDetails, id)
	var i GetClaimDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ClaimID,
		&i.PolicyNumber,
		&i.SystemStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyholderID,
		&i.ClaimType,
		&i.DateOfLoss,
		&i.DescriptionOfLoss,
		&i.ClaimAmount,
		&i.BusinessStatus,
		&i.AdjusterAssigned,
		&i.PolicyholderName,
		&i.City,
		&i.State,
		&i.CustomerSinceDate,
		&i.CustomerLevel,
	)
	return i, err
}

const getClaimStatusHistory = `-- name: GetClaimStatusHistory :many
SELECT
    ie.id AS event_id, ie.created_at AS event_timestamp, ie.event_data, u.display_name AS user_name
FROM items_events ie
JOIN users u ON ie.created_by = u.id
WHERE ie.item_id = $1 AND ie.event_type = 'CLAIM_STATUS_CHANGED'
ORDER BY ie.created_at DESC
`

type GetClaimStatusHistoryRow struct {
	EventID        int64              `json:"event_id"`
	EventTimestamp pgtype.Timestamptz `json:"event_timestamp"`
	EventData      []byte             `json:"event_data"`
	UserName       pgtype.Text        `json:"user_name"`
}

// Fetches the business status change history for a specific claim item
func (q *Queries) GetClaimStatusHistory(ctx context.Context, itemID int64) ([]GetClaimStatusHistoryRow, error) {
	rows, err := q.db.Query(ctx, getClaimStatusHistory, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimStatusHistoryRow
	for rows.Next() {
		var i GetClaimStatusHistoryRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventTimestamp,
			&i.EventData,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentHeader = `-- name: GetDocumentHeader :one
SELECT
    custom_properties->'metadata'->'source_custom_properties' as structured_metadata
FROM items
WHERE
    item_type = 'KNOWLEDGE_CHUNK'
AND
    custom_properties->'metadata'->>'document_id' = $1::text
AND
    custom_properties->'metadata'->>'chunk_number' = '0'
LIMIT 1
`

// Fetches the header chunk's source_custom_properties for a given document ID.
func (q *Queries) GetDocumentHeader(ctx context.Context, documentID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getDocumentHeader, documentID)
	var structured_metadata interface{}
	err := row.Scan(&structured_metadata)
	return structured_metadata, err
}

const listClaimsWithVector = `-- name: ListClaimsWithVector :many
SELECT
    id, item_type, claim_id, policy_number, system_status, created_at, updated_at,
    policyholder_id, claim_type, date_of_loss, description_of_loss, claim_amount,
    business_status, adjuster_assigned,
    (embedding <=> $1::vector) as similarity_score
FROM vw_insurance_claims
WHERE
    ($2::text IS NULL OR claim_id = $2)
AND ($3::decimal IS NULL OR claim_amount >= $3)
AND ($4::decimal IS NULL OR claim_amount <= $4)
AND ($5::text IS NULL OR adjuster_assigned = $5)
AND ($6::text IS NULL OR business_status = $6)
AND ($7::text IS NULL OR policy_number = $7)
AND (embedding <=> $1::vector) < 0.5
ORDER BY similarity_score ASC
LIMIT $9 OFFSET $8
`

type ListClaimsWithVectorParams struct {
	SearchEmbedding  pgvector.Vector `json:"search_embedding"`
	ClaimID          pgtype.Text     `json:"claim_id"`
	MinAmount        pgtype.Numeric  `json:"min_amount"`
	MaxAmount        pgtype.Numeric  `json:"max_amount"`
	AdjusterAssigned pgtype.Text     `json:"adjuster_assigned"`
	Status           pgtype.Text     `json:"status"`
	PolicyNumber     pgtype.Text     `json:"policy_number"`
	Offset           int32           `json:"offset"`
	Limit            int32           `json:"limit"`
}

type ListClaimsWithVectorRow struct {
	ID                int64              `json:"id"`
	ItemType          ItemType           `json:"item_type"`
	ClaimID           pgtype.Text        `json:"claim_id"`
	PolicyNumber      pgtype.Text        `json:"policy_number"`
	SystemStatus      ItemStatus         `json:"system_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PolicyholderID    string             `json:"policyholder_id"`
	ClaimType         string             `json:"claim_type"`
	DateOfLoss        pgtype.Date        `json:"date_of_loss"`
	DescriptionOfLoss string             `json:"description_of_loss"`
	ClaimAmount       pgtype.Numeric     `json:"claim_amount"`
	BusinessStatus    string             `json:"business_status"`
	AdjusterAssigned  string             `json:"adjuster_assigned"`
	SimilarityScore   interface{}        `json:"similarity_score"`
}

// Fetches and sorts claims by semantic similarity.
func (q *Queries) ListClaimsWithVector(ctx context.Context, arg ListClaimsWithVectorParams) ([]ListClaimsWithVectorRow, error) {
	rows, err := q.db.Query(ctx, listClaimsWithVector,
		arg.SearchEmbedding,
		arg.ClaimID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.AdjusterAssigned,
		arg.Status,
		arg.PolicyNumber,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClaimsWithVectorRow
	for rows.Next() {
		var i ListClaimsWithVectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ClaimID,
			&i.PolicyNumber,
			&i.SystemStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderID,
			&i.ClaimType,
			&i.DateOfLoss,
			&i.DescriptionOfLoss,
			&i.ClaimAmount,
			&i.BusinessStatus,
			&i.AdjusterAssigned,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClaimsWithoutVector = `-- name: ListClaimsWithoutVector :many
SELECT
    id, item_type, claim_id, policy_number, system_status, created_at, updated_at,
    policyholder_id, claim_type, date_of_loss, description_of_loss, claim_amount,
    business_status, adjuster_assigned,
    NULL::float8 as similarity_score
FROM vw_insurance_claims
WHERE
    ($1::text IS NULL OR claim_id = $1)
AND ($2::decimal IS NULL OR claim_amount >= $2)
AND ($3::decimal IS NULL OR claim_amount <= $3)
AND ($4::text IS NULL OR adjuster_assigned = $4)
AND ($5::text IS NULL OR business_status = $5)
AND ($6::text IS NULL OR policy_number = $6)
ORDER BY
    CASE WHEN $7::text = 'claim_amount' AND $8::text = 'asc' THEN claim_amount END ASC,
    CASE WHEN $7::text = 'claim_amount' AND $8::text = 'desc' THEN claim_amount END DESC,
    date_of_loss DESC
LIMIT $10 OFFSET $9
`

type ListClaimsWithoutVectorParams struct {
	ClaimID          pgtype.Text    `json:"claim_id"`
	MinAmount        pgtype.Numeric `json:"min_amount"`
	MaxAmount        pgtype.Numeric `json:"max_amount"`
	AdjusterAssigned pgtype.Text    `json:"adjuster_assigned"`
	Status           pgtype.Text    `json:"status"`
	PolicyNumber     pgtype.Text    `json:"policy_number"`
	SortBy           string         `json:"sort_by"`
	SortDirection    string         `json:"sort_direction"`
	Offset           int32          `json:"offset"`
	Limit            int32          `json:"limit"`
}

type ListClaimsWithoutVectorRow struct {
	ID                int64              `json:"id"`
	ItemType          ItemType           `json:"item_type"`
	ClaimID           pgtype.Text        `json:"claim_id"`
	PolicyNumber      pgtype.Text        `json:"policy_number"`
	SystemStatus      ItemStatus         `json:"system_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PolicyholderID    string             `json:"policyholder_id"`
	ClaimType         string             `json:"claim_type"`
	DateOfLoss        pgtype.Date        `json:"date_of_loss"`
	DescriptionOfLoss string             `json:"description_of_loss"`
	ClaimAmount       pgtype.Numeric     `json:"claim_amount"`
	BusinessStatus    string             `json:"business_status"`
	AdjusterAssigned  string             `json:"adjuster_assigned"`
	SimilarityScore   pgtype.Float8      `json:"similarity_score"`
}

// Fetches a paginated and filtered list of insurance claims without vector search.
func (q *Queries) ListClaimsWithoutVector(ctx context.Context, arg ListClaimsWithoutVectorParams) ([]ListClaimsWithoutVectorRow, error) {
	rows, err := q.db.Query(ctx, listClaimsWithoutVector,
		arg.ClaimID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.AdjusterAssigned,
		arg.Status,
		arg.PolicyNumber,
		arg.SortBy,
		arg.SortDirection,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClaimsWithoutVectorRow
	for rows.Next() {
		var i ListClaimsWithoutVectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ClaimID,
			&i.PolicyNumber,
			&i.SystemStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderID,
			&i.ClaimType,
			&i.DateOfLoss,
			&i.DescriptionOfLoss,
			&i.ClaimAmount,
			&i.BusinessStatus,
			&i.AdjusterAssigned,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicyholders = `-- name: ListPolicyholders :many
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE
    state = COALESCE($1, state)
AND
    customer_level = COALESCE($2, customer_level)
ORDER BY
    policyholder_name
LIMIT $4
OFFSET $3
`

type ListPolicyholdersParams struct {
	State         pgtype.Text `json:"state"`
	CustomerLevel pgtype.Text `json:"customer_level"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

// Fetches a paginated and filtered list of policyholders.
func (q *Queries) ListPolicyholders(ctx context.Context, arg ListPolicyholdersParams) ([]VwPolicyholder, error) {
	rows, err := q.db.Query(ctx, listPolicyholders,
		arg.State,
		arg.CustomerLevel,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwPolicyholder
	for rows.Next() {
		var i VwPolicyholder
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.PolicyholderID,
			&i.State,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderName,
			&i.City,
			&i.CustomerSinceDate,
			&i.CustomerLevel,
			&i.ActivePolicies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchComments = `-- name: SearchComments :many
SELECT
    'Comment' AS source,
    comment::TEXT AS text,
    i.business_key AS claim_id,
    c.embedding <=> $1::vector AS similarity_score
FROM comments c
JOIN items i ON c.item_id = i.id
WHERE c.embedding IS NOT NULL
ORDER BY similarity_score ASC
LIMIT $2
`

type SearchCommentsParams struct {
	Embedding pgvector.Vector `json:"embedding"`
	Limit     int32           `json:"limit"`
}

type SearchCommentsRow struct {
	Source          string      `json:"source"`
	Text            string      `json:"text"`
	ClaimID         pgtype.Text `json:"claim_id"`
	SimilarityScore interface{} `json:"similarity_score"`
}

// Searches comments semantically.
func (q *Queries) SearchComments(ctx context.Context, arg SearchCommentsParams) ([]SearchCommentsRow, error) {
	rows, err := q.db.Query(ctx, searchComments, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCommentsRow
	for rows.Next() {
		var i SearchCommentsRow
		if err := rows.Scan(
			&i.Source,
			&i.Text,
			&i.ClaimID,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKnowledgeChunks = `-- name: SearchKnowledgeChunks :many
SELECT
    (
    COALESCE(custom_properties->>'metadata.section', 'General Information') ||
    ' from ' ||
    COALESCE(custom_properties->>'metadata.document_name', 'Unknown Document')
    ) AS source,
    COALESCE((custom_properties->>'chunk_text')::TEXT, '') AS text,
    embedding <=> $1::vector AS similarity_score,
    custom_properties->>'metadata.source_custom_properties' AS structured_metadata
FROM items
WHERE
    item_type = 'KNOWLEDGE_CHUNK' AND embedding IS NOT NULL
ORDER BY similarity_score ASC
LIMIT $2
`

type SearchKnowledgeChunksParams struct {
	Embedding pgvector.Vector `json:"embedding"`
	Limit     int32           `json:"limit"`
}

type SearchKnowledgeChunksRow struct {
	Source             interface{} `json:"source"`
	Text               interface{} `json:"text"`
	SimilarityScore    interface{} `json:"similarity_score"`
	StructuredMetadata interface{} `json:"structured_metadata"`
}

// Searches semantically the knowledge base
func (q *Queries) SearchKnowledgeChunks(ctx context.Context, arg SearchKnowledgeChunksParams) ([]SearchKnowledgeChunksRow, error) {
	rows, err := q.db.Query(ctx, searchKnowledgeChunks, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKnowledgeChunksRow
	for rows.Next() {
		var i SearchKnowledgeChunksRow
		if err := rows.Scan(
			&i.Source,
			&i.Text,
			&i.SimilarityScore,
			&i.StructuredMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
